---
создал заметку: "2025-03-01"
---
[Оригинал](https://earthly.dev/blog/linux-text-processing-commands/)

Стандартный ввод (stdin), стандартный вывод (stdout) и стандартная ошибка (stderr) — это три стандартных потока, которые позволяют пользователям взаимодействовать с командами и скриптами в Linux.

## **Потоки вывода информации**

**Stdin** - сокращение от *Standard input*, это способ, которым вы даете ввод программе. Например: **`grep something file.txt`**

Команда выше считывает содержимое файла, ищет шаблон, затем выводит результат поиска в вашей оболочке. В этом случае содержимое file.txt — это stdin.

**Stdout** — сокращение от *Standard output*, это поток вывода, в который программа записывает свои выходные данные. Это может быть терминал или файл в системе (если у вас достаточно привилегий).

**Stderr** — сокращение от *Standard error*, это выходной поток, в который программа записывает ошибку. Подобно стандартному выводу, вы можете перенаправить выходное сообщение об ошибке в файл с помощью оператора `2>`.

## **Pipes, Redirection**

##### **Pipes**

В системах Unix **pipe** используется для создания связи между двумя командами. С **pipe** вывод одной команды действует как ввод для другой команды:
```sh
echo "Hello World" | tr [a-z] [A-Z]
```

Output: `HELLO WORLD`

##### **Redirection**

Оператор `>` используется для перенаправления вывода команды в файл:
**`ls -la > myfile`** - Содержимое текущей директории запишется в *myfile*

Если вы используете `>`, то он заменит старое содержимое файла на новое(перезапишет)

Оператор `>>` используется для добавления вывода команды в конец существующего файла или записи в новый файл.
**`ls -la >> myfile`** - Теперь у нас будут два вывода в *myfile*

Оператор `<` используется для чтения из файла и последующего действия с ним.
**`wc -l < numbers.txt > lines.txt`** - Приведенная команда берет входные данные команды wc line count из файла numbers.txt и перенаправляет количество строк в файл с именем lines.txt.

Оператор `2>` используется для перенаправления сообщений об ошибках в определенный файл. Это полезно, когда вы выполняете команду или скрипт в своей системе и хотите зафиксировать ошибку, если что-то пойдет не так:

**Например**: **`ls несуществующий_файл 2> errors.log`**
	Обычный вывод (stdout) будет на экране.
	Ошибки (stderr) запишутся в файл `errors.log`
	Число `2` — это дескриптор stderr (0 — stdin, 1 — stdout).
	Символ `>` указывает на перенаправление вывода.

**Игнорирование об ошибках**
**`rm файл 2> /dev/null`** - Сообщения об ошибках (например, если файла нет) отправляются в `/dev/null` (виртуальное "устройство", которое их удаляет).

**Разделение stdout и stderr**
**`python script.py > output.log 2> errors.log`** - Результат работы скрипта (stdout) сохраняется в `output.log`. Ошибки (stderr) — в `errors.log`.

**Объединение stdout и stderr**

```sh
ls файл > combined.log 2>&1
# Или сокращённо:
ls файл &> combined.log
```
Оба потока объединяются и записываются в `combined.log`.

**Добавление ошибок в конец файла**
**`grep "ERROR" /var/log/syslog 2>> debug_errors.log`** - Ошибки дописываются в конец файла `debug_errors.log` (без перезаписи).

**Порядок перенаправлений важен!**
`команда > файл 2>&1` — оба потока в файл.
`команда 2>&1 > файл` — stderr останется на экране, а stdout уйдёт в файл

## **Регулярные выражения**

Например, вы можете выбрать и выполнить команду Go, например go fmt, для всех файлов Go в текущем каталоге, как показано ниже:

```sh
ls *.go | go fmt
```


Вышеуказанный шаблон регулярного выражения `*.go` означает все файлы, которые заканчиваются на `.go`. Команда выведет список всех файлов, которые заканчиваются на .go, и выполнит для них команду `go fmt`.

Допустим, вы хотите найти шаблон, скажем, все слова, содержащие k8s или kubernetes в файле с именем blog.md:

```sh
grep k*s blog.md
```

В `k*s` используется подстановочный знак (`*`), который означает, что в искомой строке между «k» и «s» могут находиться любые символы.

Таким образом, команда вернет все строки в файле «blog.md», содержащие слова с «k» и «s» в качестве первого и последнего символа соответственно, с любым количеством символов между ними. Сюда входят такие слова, как «k8s», «kubernetes».

Однако шаблон `k*s` не является точным совпадением для «k8s» или «kubernetes». Он также будет соответствовать таким словам, как «kafka-streams», «keyspaces».

Другой пример использования шаблона **regex** — когда вы хотите найти все *'example'* в записи блога. Для этой цели вы можете вызвать следующую команду:

```sh
grep ^example blog.md
```

Будет выполнен поиск всех слов в документе, начинающихся с example.

## **Базовые команды обработки текста в Linux**

**cut** - используется для вырезания разделов из каждой строки файлов и записи результата в стандартный вывод. Вы можете использовать ее для извлечения определенного столбца из файла и его печати в стандартный вывод.

Параметр `-f` используется для указания полей, которые необходимо извлечь, а `1` указывает первое поле.

Опция `-d` обозначает разделитель, в данном случае разделителем является запятая. Его лучше сразу указывать, т.к. без него может не работать.

Содержимое объекта **file**:
```sh
hi hello privet
2 4 5
good work team
```

```sh
$ cut file -f 1 -d " "
hi
2
good
```

Также можно писать через `-`, если нужно несколько столбцов или строк.
```sh
$ cut file -f 2-3 -d " "
hello privet
4 5
work team
```

**sort** - Команда sort используется для упорядочивания строк в текстовых файлах в определенном порядке. По умолчанию команда sort сортирует содержимое файла в порядке возрастания.
`-r` - отсортировать содержимое в порядке убывания

Некоторые из распространенных флагов включают `-f` для игнорирования регистра и флаг `-o` для записи вывода в определенный файл.

**tac** - Команда tac выводит содержимое вашего файла в обратном порядке. Если вы знакомы с командой cat, команда tac просто возвращает обратный вывод команды cat.

**uniq** - Команда uniq используется для сообщения или пропуска повторяющихся строк. Эта команда печатает только уникальные строки. Она удалит только *соседние повторяющиеся строки*.
`-u` - удалить все повторяющиеся строки из файла
`-c` - для подсчета количества появлений каждой строки

**sed** - используется для выполнения различных операций с текстовыми потоками, включая поиск и замену, фильтрацию текста и нумерацию строк.

Рассмотрим пример, который ищет и заменяет k8s на kubernetes в контенте блога:

```sh
sed 's/k8s/kubernetes/g' blog.md
```

В приведенном выше случае `s` означает, что мы хотим заменить слово, `k8s` — это слово, которое мы хотим заменить, а `kubernetes` — это слово, которое мы хотим заменить для `k8s`. `g` в команде означает, что мы хотим, чтобы эта команда была выполнена в глобальном масштабе, что означает, что каждый экземпляр соответствия будет заменен. Если вызвать команду без `g`, то только первый экземпляр `k8s` будет заменен на kubernetes.

**awk** - с помощью awk можно выполнять очень сложную обработку текста, например суммирование чисел в столбце файла, фильтрацию на основе условия, группировку и агрегацию данных и т. д.
`-F` - устанавливает разделитель полей на `,` что означает, что awk будет обрабатывать файл как разделенное запятыми значение.
`{print $2}` - awk проходит по каждой строке файла и печатает второе поле(столбец)

**Пример:** чтобы вычислить сумму возрастов в файле
**`awk -F , '{sum+=$2} END {print sum}' demo.csv`** - Output: `103`

Приведенная выше команда вычисляет сумму второго поля в файле. `{sum+=2}` будет искать второе значение в каждом поле, а затем добавлять его к переменной суммы. `END {print sum}` будет выполнена, когда все строки будут обработаны, и выведет окончательное значение переменной суммы.

При выполнении числовых вычислений над содержимым файла можно игнорировать первую строку файла, если это заголовок, который в большинстве случаев представляет собой строки: `awk -F , 'NR>1 {print $2}' demo.csv`

`NR` относится к количеству записей. `NR>1` в приведенных выше примерах означает, что не будет включена первая запись, которая является заголовком, а не числовыми данными (`age`).

**tr** - может использоваться для перевода или удаления символов из стандартного ввода и записи результата в стандартный вывод. Некоторые из распространенных вариантов использования команды `tr` включают:

- *Перевод символов из одного набора в другой:* вы можете использовать команду для перевода всех символов из заглавных в строчные и наоборот.
- *Удаление повторяющихся символов:* вы можете использовать команду для удаления повторяющихся символов из потока текста.
- *Удаление символов:* Вы можете использовать их для удаления определенных символов из ввода. Например, вы можете использовать команду tr для удаления всех цифр из ввода.

```sh
echo "Hello World" | tr [A-Z] [a-z]
```

Output: `hello world`

Для той же цели можно использовать следующий синтаксис.

```sh
echo "Hello" | tr [:upper] [:lower]
```

**wc** - word count (количество слов). Это команда, которую можно использовать для подсчета количества строк, слов и символов в файле.
`-l` - для количества строк 
`-w` - слов
`-c` - символов

**tee** - позволяет перенаправить вывод операции в несколько потоков одновременно, например, в stdout и файл. Это позволяет просматривать вывод в реальном времени и сохранять его для будущего использования.

**xargs** - позволяет передавать вывод одной команды в качестве аргумента другой команде.

Синтаксис показан ниже:
```sh
command1 | xargs command2
```

Например: в текстовом файле написано `-la`. В консоль вводим `cat text | xargs ls` и таким образом у нас запустится команда `ls` с параметром `-la`

Одним из распространенных вариантов использования команды xargs является выполнение пакетной операции над большим количеством файлов.

Например, если вы хотите удалить все файлы в текущем рабочем каталоге.

```sh
ls | xargs rm
```

`-p` или `--interactive` - чтобы запросить у пользователя подтверждение перед запуском следующей команды

Команду `xargs` можно также использовать, когда конкретная команда или подкоманда принимает только ограниченное количество аргументов одновременно, но вы хотите одновременно работать с количеством аргументов, превышающим установленный лимит.

**rg** -  это современная альтернатива grep. Это быстрый инструмент поиска в командной строке, который рекурсивно ищет файлы в текущем каталоге по шаблону регулярного выражения. Он написан на Rust и очень быстр.

**bat** - это современная альтернатива команде cat. Она поддерживает подсветку синтаксиса для множества языков и поставляется с большим количеством параметров конфигурации. Для настройки bat вы можете отредактировать файл конфигурации bat в ~/.config/bat/config.

**fd** - Команда fd позволяет вам искать файлы по имени файлов в вашей системе. Команда find в Linux может показаться запутанной поначалу, потому что она поставляется со множеством флагов, и когда вы хотите найти файл, это может быть утомительно. Одна из лучших альтернатив find — fd. Она проста, быстра и удобна для пользователя. Она поставляется с идеальными параметрами по умолчанию, которые упрощают ее использование. Вам просто нужно указать шаблон файла, и она выдаст вам вывод.

**Заключение:** В этом блоге мы рассмотрели множество команд обработки текста Linux, включая sed, grep, awk, tr, wc, cut, sort, tac, bat, fd, uniq и xargs. Сочетание этих инструментов поможет вам выполнить широкий спектр необходимых текстовых манипуляций в вашем ежедневном рабочем процессе, от поиска и замены текста до извлечения данных из файла.